#include <stdio.h>#include <stdlib.h>#include <string.h>#include <sys/stat.h>#include <string.h>#include <locale.h>#include <unistd.h>#include <sys/types.h>#include <sys/socket.h>#include <netinet/in.h>#include <arpa/inet.h>#include <netdb.h>#include <sys/time.h>#include "utoall.h"#include "utoplt01.h"#include "pasdb.h"#include "ncportal.h"#include <iconv.h>#include <iconv.h>#include <ctype.h>#include <openssl/crypto.h>#include <openssl/ssl.h>#include <openssl/err.h>#include <openssl/rand.h>#include "cjson.h"#include "ict_wp_tool.h"#define DEBUG 1//post方式获取内容char *getXmlConByPost(char *pUrl, char *pPostVar){    int sockfd, ret;    char buffer[1024];    struct sockaddr_in server_addr;    struct hostent *host;    int portnumber, nbytes;    char host_addr[256];    char host_file[1024];    char local_file[256];    char request[1024];    int send, totalsend;    int i;    char *pt;    SSL *ssl;    SSL_CTX *ctx;    char tmpch[4] = "";    static char pCont[10024] = "";    //    strcpy(argv,"https://api.weixin.qq.com/cgi-bin/menu/create?access_token=");    GetHost(pUrl, host_addr, host_file, &portnumber);        /*分析网址、端口、文件名等 */    if(DEBUG)        printf("webhost:%s\n", host_addr);    if(DEBUG)        printf("hostfile:%s\n", host_file);    if(DEBUG)        printf("portnumber:%d\n\n", portnumber);    //    if ((host = gethostbyname(host_addr)) == NULL) {        /*取得主机IP地址 */    //        if (DEBUG)    //            fprintf(stderr, "Gethostname error, %s\n", strerror(errno));    //        exit(1);    //    }    if((host = gethostbyname(host_addr)) == NULL)           /*取得主机IP地址 */    {        if(DEBUG)            fprintf(stderr, "Gethostname error, %s\n", strerror(errno));        exit(1);    }    /* 客户程序开始建立 sockfd描述符 */    if((sockfd = socket(AF_INET, SOCK_STREAM, 0)) == -1)           /*建立SOCKET连接 */    {        if(DEBUG)            fprintf(stderr, "Socket Error:%s\a\n", strerror(errno));        exit(1);    }    /* 客户程序填充服务端的资料 */    bzero(&server_addr, sizeof(server_addr));    server_addr.sin_family = AF_INET;    server_addr.sin_port = htons(portnumber);    server_addr.sin_addr = *((struct in_addr *) host->h_addr);    /* 客户程序发起连接请求 */    if(connect(sockfd, (struct sockaddr *)(&server_addr), sizeof(struct sockaddr)) == -1)            /*连接网站 */    {        if(DEBUG)            fprintf(stderr, "Connect Error:%s\a\n", strerror(errno));        exit(1);    }    /* SSL初始化 */    SSL_library_init();    SSL_load_error_strings();    ctx = SSL_CTX_new(SSLv23_client_method());    if(ctx == NULL)    {        ERR_print_errors_fp(stderr);        exit(1);    }    ssl = SSL_new(ctx);    if(ssl == NULL)    {        ERR_print_errors_fp(stderr);        exit(1);    }    /* 把socket和SSL关联 */    ret = SSL_set_fd(ssl, sockfd);    if(ret == 0)    {        ERR_print_errors_fp(stderr);        exit(1);    }    RAND_poll();    while(RAND_status() == 0)    {        unsigned short rand_ret = rand() % 65536;        RAND_seed(&rand_ret, sizeof(rand_ret));    }    ret = SSL_connect(ssl);    if(ret != 1)    {        ERR_print_errors_fp(stderr);        exit(1);    }    //host_file    /*    post格式说明：每行前不可以有空格    POST https://api.weixin.qq.com/cgi-bin/menu/create?access_token=lQEAXOvehXccOPDfSCCX50giI46RlcT2X_OqrhS_sbTkIi0laDx8bfMDGVEKD3IVgQl24PuiP9rXHKvskdTcOoPcRbj-K5NXfRxBSGNUgIaorMl3Z4Jx6WUnnAvAChVorpTh-cViMxiJltMNtC2LNg HTTP/1.1    Accept: *\/*    Accept-Language: zh-cn    User-Agent: Mozilla/4.0 (compatible; MSIE 5.01; Windows NT 5.0)    Content-Type: application/json               //must    Host: api.weixin.qq.com:443    Connection: Keep-Alive    Content-Length: 68                           //must    {"button":[{"type":"click","name":"Wifi Net","key":"ncm_wifi_net"}]}    506 bytes send OK!    The following is the response header:    HTTP/1.1 200 OK    Server: nginx/1.4.4    Date: Thu, 27 Mar 2014 06:16:11 GMT    Content-Type: application/json; encoding=utf-8    Content-Length: 27    Connection: close    {"errcode":0,"errmsg":"ok"}    */	sprintf(request, "POST %s HTTP/1.1\r\nAccept: */*\r\nAccept-Language: UTF-8\r\n\	User-Agent: Mozilla/4.0 (compatible; MSIE 5.01; Windows NT 5.0)\r\n\Content-Type: application/json\r\n\	Host: %s:%d\r\nConnection: Keep-Alive\r\nContent-Length: %d\r\n\r\n%s\r\n\r\n", pUrl, host_addr,				portnumber, strlen(pPostVar), pPostVar);	if(DEBUG)        printf("%s", request);        /*准备request，将要发送给主机 */    /*发送https请求request */    send = 0;    totalsend = 0;    nbytes = strlen(request);    while(totalsend < nbytes)    {        send = SSL_write(ssl, request + totalsend, nbytes - totalsend);        if(send == -1)        {            if(DEBUG)                ERR_print_errors_fp(stderr);            exit(0);        }        totalsend += send;        if(DEBUG)            printf("%d bytes send OK!\n", totalsend);    }    if(DEBUG)        printf("\nThe following is the response header:\n");    i = 0;    /* 连接成功了，接收https响应，response */    while((nbytes = SSL_read(ssl, buffer, 1)) == 1)    {        if(i < 4)        {            if(buffer[0] == '\r' || buffer[0] == '\n')                i++;            else                i = 0;            if(DEBUG)                printf("%c", buffer[0]);        /*把https头信息打印在屏幕上 */        }        else        {            if(DEBUG)                printf("%c", buffer[0]);            sprintf(tmpch, "%c", buffer[0]);            if(i == 4)            {                strcpy(pCont, tmpch);            }            else            {                strcat(pCont, tmpch);            }            i++;        }    }    /* 结束通讯 */    ret = SSL_shutdown(ssl);    if(ret != 1)    {        ERR_print_errors_fp(stderr);        //        exit(1);    }    close(sockfd);    SSL_free(ssl);    SSL_CTX_free(ctx);    ERR_free_strings();    static char caReturn[1024];    pasUtf8ToGBK(pCont, caReturn, 1000);    printf("return=%s\n", caReturn);    return (char *)caReturn;}int removeCData(char* originStr, char* newStr, ulong maxLenth){    char cDataLeft[16] = "<![CDATA[";    char cDataRight[16] = "]]>";    ncUtlGetWordBetween(originStr, cDataLeft, cDataRight, newStr, maxLenth);    return 0;}int getNodeValue(char* outXml, char* startStr, char* endStr, char* outStr, ulong maxLength){    char caTemp[128] = "";    ncUtlGetWordBetween(outXml, startStr, endStr, caTemp, 128);    removeCData(caTemp, outStr,  maxLength);    return 0;}
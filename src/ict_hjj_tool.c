#include <stdio.h>#include <stdlib.h>#include <string.h>#include <sys/stat.h>#include <string.h>#include <locale.h>#include <unistd.h>#include <sys/types.h>#include <sys/socket.h>#include <netinet/in.h>#include <arpa/inet.h>#include <netdb.h>#include <sys/time.h>#include "utoall.h"#include "utoplt01.h"#include "pasdb.h"#include "ncportal.h"#include <iconv.h>#include "ict_hjj_tool.h"//查询是否有特定表名的表int checkTableExists(char* tableName){    char sql[1024] = "";    int ret = 0;    pasDbCursor *psCur = NULL;    snprintf(sql, sizeof(sql), "select count(*) from %s", tableName);    psCur = pasDbOpenSql(sql, 0);    if(psCur != NULL)    {        ret = 1;        pasDbCloseCursor(psCur);    }    return ret;}//得到新的表，没有则创建char* getNewLogTable(char* tableOri, char * yearMonth){    static char newTable[64] = "";    snprintf(newTable, sizeof(newTable) - 1, "%s_%s", tableOri, yearMonth);    char sql[1024] = "";    if(!checkTableExists(newTable))    {        snprintf(sql, sizeof(sql) - 1, "create table %s like %s", newTable, tableOri);        printf("not exist logTable=%s, do sql=%s\n", newTable, sql);        //执行sql语句        pasDbExecSqlF(sql);    }    return newTable;}//从共享内存中取订购套餐状态int getOrderStatusFromShm(utShmHead *psShmHead, int iFd, utMsgHead *psMsgHead, char *caOrderno){    int ireturn = 0;    ictOrderNo* psData = (ictOrderNo*)utShmHashLookA(psShmHead, ICT_ORDER_PACKAGE_ORDERNO, caOrderno);    if((psData->packageid) > 0)    {        ireturn = psData->status;//status=0表示订单已创建，但是还未完成，status=1表示订单顺利完成        return ireturn;    }    else    {        //套餐订单不存在        return 2;    }}//完成订购，在接收支付宝的支付结果时处理数据库更新int ict_complete_package_order_zf(utShmHead *psShmHead, int iFd, utMsgHead *psMsgHead, char *caOrderno){    utMsgPrintMsg(psMsgHead);//在终端打印出信息    char caUsername[32] = {0};//虚拟身份号，现已改为username    char caPassword[32] = {0};//账户密码    ulong lGroupid = 0; //部门ID    char caMobno[24] = {0};//用户绑定的手机号    char caMark[128] = {0}; //产品标示    uint8 u8TimeVal = 0;//套餐生效日期    char caTimeVal[16] = {0};//套餐生效日期(临时参数)    uint4 u4PackageId = 0;//新的套餐id    char caPackageName[32] = {0};//新的套餐名称    char caAutoxiding[4] = {0};//是否自动续订,1为自动续订,0为不自定续订    char caPackageId[16] = {0};//新的套餐id(临时参数)    uint4 u4UserPackageId = 0;//旧的套餐对应在userorderid的主键id    char caUserPackageId[16] = {0};//旧的套餐id(userpackage的id,临时参数)    char caStatus[4] = {0};//userorder的状态,1生效,2失效    //char caOrderno[32] = ""; //生成的订单号    char caPackageTransactionNo[24] = "";//支付接口提供方的交易号    //要通过sql语句获取的变量    uint4 u4PackageMoney = 0;//套餐金额    uint4 u4OldPackageMoney = 0;//原套餐金额    uint4 u4Pdays = 0;//套餐天数    uint4 u4OldAccountMoney = 0;//订购前的账户余额    //通过计算获得的变量    uint8 u8StartTime = 0;//套餐开始时间    uint8 u8EndTime = 0;//套餐结束时间    uint8 u8OldPackageEndTime = 0;//当前旧套餐的结束时间    uint8 u8NowTime = 0;//系统当前时间戳    int iDstatus = 1;//订购状态，更改套餐的订购状态为已支付    uint8 u8Dtime = time(0);//订购时间为当前系统时间    char caPaymentType[4] = "";//订购套餐支付方式，1为余额,2为银行转账,3为支付宝,4为微信    char caEffectType[4] = "";//套餐生效方式,1为立即生效,2为原套餐结束后生效    int iPaymentType = 0;//订购套餐支付方式(int型,方便比较)    int iEffectType = 0;//套餐生效方式(int型，方便比较)    ulong lCount = 0;    char caMsg[256] = {0};    char caTsid[24] = {0};    int iReturn = 0;    char caUserorderTableName[128] = {0};//当月的用户订购套餐日志表名    char caStemptime[32] = {0};//当月的时间格式(%Y%m)    char userOrderLogType[4] = {0};//订购套餐日志类型,1为订购,2为升级    uint4 u4NewAccountMoney = 0;//余额付款，更新后的账户余额    char caOldPackageName[32] = {0};//旧的套餐名称    char sqlbuf[1024] = "";    utPltDbHead *psDbHead = utPltInitDbHead();    //验证从支付宝后台传过来的orderPackageNo在共享内存中是否存在    pasLogs(1223, 1223, "before_complete_package_order caOrderno =[%s]\n", caOrderno);    pasLogs(1223, 1223, "before_complete_package_order caOrderno.strlen =[%d]\n", strlen(caOrderno));    pasHashInfo sHashInfo;    uchar *pHash;    ictOrderNo* psData = (ictOrderNo*)utShmHashLookA(psShmHead, ICT_ORDER_PACKAGE_ORDERNO, caOrderno);    if(((psData->packageid) > 0) && (psData->status == 0))    {        iPaymentType = psData->paymentType;        iEffectType = psData->effectType;        u4PackageId = psData->packageid;        snprintf(caAutoxiding, 3, "%s", psData->autoxiding);    }    else    {        //套餐订单不存在        //返回标志为2,不记录在status中    }    //获取新套餐的相关信息    memset(sqlbuf, 0, sizeof(sqlbuf));    snprintf(sqlbuf, sizeof(sqlbuf) - 1, "select money,namech,pdays from package where id=%u", u4PackageId);    iReturn = pasDbOneRecord(sqlbuf, 0, UT_TYPE_LONG, 4, &u4PackageMoney,                             UT_TYPE_STRING, sizeof(caPackageName) - 1, caPackageName,                             UT_TYPE_LONG, 4, &u4Pdays);    printf("sqlbuf=%s, iReturn=%d\n", sqlbuf, iReturn);    //sql语句执行成功    if((iReturn == 0) || (1405 == iReturn))    {        //获取新套餐的相关信息成功    }    else    {        psData->status = 3;        //查询新的套餐信息失败!,sql语句执行不成功!        return 1;    }    //首先在数据库中获取用户当前生效的套餐    snprintf(caUsername, sizeof(caUsername) - 1, "%s", getVnameByTsId(psShmHead, atoll(caTsid))); //根据tsid获取username    memset(sqlbuf, 0, sizeof(sqlbuf));    u8NowTime = time(0); //获取当前时间戳    snprintf(caStatus, sizeof(caStatus) - 1, "1"); //将生效状态字段改为生效,用于sql语句查询    /*select获取的数据说明     money作为用户用余额付款时，计算付款后的账户余额,并将余额返回到前台,前台更新账户余额    */    //printf("sqlbuf before======================%s\n", sqlbuf);    snprintf(sqlbuf, sizeof(sqlbuf) - 1, "select ncsrvuserex.mobno,userorder.id,userorder.endtime from ncsrvuserex,userorder where ncsrvuserex.username='%s' and userorder.username='%s' and userorder.starttime <= %llu and userorder.endtime >= %llu and userorder.status='%s'", caUsername, caUsername, u8NowTime, u8NowTime, caStatus);    //ictPrint(wpDebug, "sql=%s    \n", sqlbuf);    //printf("sqlbuf======================%s\n", sqlbuf);    //将调试信息打印到日志文件中    pasLogs(7077, 7077, "ict_complete_package_order_zf sqlbuf=%s  \n", sqlbuf);    iReturn = pasDbOneRecord(sqlbuf, 0, UT_TYPE_STRING, sizeof(caMobno) - 1, caMobno,                             UT_TYPE_LONG, 4, &u4UserPackageId,                             UT_TYPE_LONG, 8, &u8OldPackageEndTime                            );    //UT_TYPE_LONG,4, &u4OldAccountMoney, //订购套餐前的的账户余额    printf("sqlbuf=%s, iReturn=%d\n", sqlbuf, iReturn);    if((iReturn == 0) || (1405 == iReturn) || (1403 == iReturn))    {        //查询用户是否有当前生效套餐        if(strlen(caMobno) > 0)//存在当前生效套餐        {            //如果是立即生效的话，将当前套餐状态改为失效            if(iEffectType == 1)            {                //设置userorder的状态为2，失效                snprintf(caStatus, sizeof(caStatus) - 1, "2");                memset(sqlbuf, 0, sizeof(sqlbuf));                //根据userorder的id(主键)来更新数据                snprintf(sqlbuf, sizeof(sqlbuf), "update userorder set status='%s' where id =%u", caStatus, u4UserPackageId);                //printf("sqlbuf======================%s\n", sqlbuf);                pasLogs(7077, 7077, "ict_complete_package_order_zf sqlbuf=%s  \n", sqlbuf);                iReturn = pasDbExecSql(sqlbuf, 0);                memset(caMsg, 0, sizeof(caMsg));                if(iReturn != 0)                {                    psData->status = 4;                    //用户订购套餐的生效状态修改失败!,sql语句执行不成功                    pasDbRollback(NULL);//错误回滚                    return 1;                }                else                {                    //userorder表套餐生效状态修改成功                }                //设置订购套餐的生效时间为当前时间                u8StartTime = time(0);            }            else//原套餐结束后生效            {                //设置订购套餐的生效时间,为当前旧套餐的结束时间                u8StartTime = u8OldPackageEndTime;            }        }        else//没有当前生效的套餐        {            //设置订购套餐的生效时间为当前时间            u8StartTime = time(0);        }        //余额付款        if(iPaymentType == 1)        {            //获取用户账户未扣除套餐金额前的余额(选择用余额付款)            memset(sqlbuf, 0, sizeof(sqlbuf));            snprintf(sqlbuf, sizeof(sqlbuf) - 1, "select money,mobno from ncsrvuserex where username='%s'", caUsername);            //将调试信息打印到日志文件中            pasLogs(7077, 7077, "ict_complete_package_order_zf sqlbuf=%s  \n", sqlbuf);            iReturn = pasDbOneRecord(sqlbuf, 0, UT_TYPE_LONG, 4, &u4OldAccountMoney, //订购套餐前的的账户余额                                     UT_TYPE_STRING, sizeof(caMobno) - 1, caMobno                                    );            printf("sqlbuf=%s, iReturn=%d\n", sqlbuf, iReturn);            if((iReturn == 0) || (1405 == iReturn))            {                //查询账户余额成功，            }            else            {                //查询账户余额失败，包括数据为空                //psData.status = 5;                return 1;            }            //余额充值，再次验证            if(u4OldAccountMoney < u4PackageMoney)            {                //账户余额不足                //psData.status = 6;                pasDbRollback(NULL);//错误回滚                return 1;            }            u4NewAccountMoney = u4OldAccountMoney - u4PackageMoney;//计算扣款后的余额(数据库中以分为单位，传到前台的是分为单位)            pasLogs(1223, 1223, "ict_complete_package_order u4NewAccountMoney =%lu\n", u4NewAccountMoney);            pasLogs(1223, 1223, "ict_complete_package_order u4OldAccountMoney =%lu\n", u4OldAccountMoney);            pasLogs(1223, 1223, "ict_complete_package_order u4PackageMoney =%lu\n", u4PackageMoney);            pasLogs(1223, 1223, "ict_complete_package_order caOrderno =%s\n", caOrderno);            printf("u4OldAccountMoney=%lu\n", u4OldAccountMoney);            printf("u4PackageMoney=%lu\n", u4PackageMoney);            printf("u4NewAccountMoney=%lu\n", u4NewAccountMoney);            //执行余额付款            memset(sqlbuf, 0, sizeof(sqlbuf));            snprintf(sqlbuf, sizeof(sqlbuf) - 1, "update ncsrvuserex set money=%lu where username ='%s'", u4NewAccountMoney, caUsername);            //printf("sqlbuf===========================%s\n", sqlbuf);            pasLogs(7077, 7077, "ict_complete_package_order_zf sqlbuf=%s  \n", sqlbuf);            iReturn = pasDbExecSql(sqlbuf, 0);            memset(caMsg, 0, sizeof(caMsg));            if(iReturn != 0)            {               // psData.status = 7;                //用户余额修改失败!,sql语句执行不成功!                pasDbRollback(NULL);//错误回滚                return 1;            }            else            {                //用户余额修改成功!            }        }        else        {            //不是余额付款,不做操作        }    }    else    {        //psData.status = 8;        //查询用户是否有当前生效套餐!,sql语句执行不成功!        return 1;    }    //公共调用的模块    //模块一、添加用户订购套餐信息    u8EndTime = u8StartTime + (u4Pdays * 24 * 60 * 60);    //获取产品标识mark    snprintf(caMark, sizeof(caMark) - 1, "%s", utComGetVar_sd(psShmHead, "mark", "0"));    printf("caMark=====================%s\n", caMark);    //snprintf(caAutoxiding, sizeof(caAutoxiding) - 1, "0");    //设置套餐状态，设置为1.生效    snprintf(caStatus, sizeof(caStatus) - 1, "1");    //设置订购时间    u8Dtime = time(0);    memset(sqlbuf, 0, sizeof(sqlbuf));    printf("insert into userorder==========================================\n");    snprintf(sqlbuf, sizeof(sqlbuf), "insert into userorder (username,mobno,mark,packageid,name,starttime,endtime,autoxiding,status,timeval)values('%s','%s','%s',%lu,'%s',%llu,%llu,'%s','%s',%llu)", caUsername, caMobno, caMark, u4PackageId, caPackageName, u8StartTime, u8EndTime, caAutoxiding, caStatus, u8Dtime);    //printf("sqlbuf=%s, iReturn=%d\n", sqlbuf, iReturn);    pasLogs(7077, 7077, "ict_complete_package_order_zf sqlbuf=%s, iReturn=%d\n", sqlbuf, iReturn);    iReturn = pasDbExecSql(sqlbuf, 0);    memset(caMsg, 0, sizeof(caMsg));    if(iReturn != 0)    {        //psData.status = 9;        //添加用户订购套餐信息!,sql语句执行不成功!        pasDbRollback(NULL);//错误回滚        return 1;    }    else    {        //添加用户订购套餐信息成功    }    //模块二、添加用户订购套餐日志    //获得用户订购套餐日志表名,没有则创建    long letime = time(0);    snprintf(caStemptime, sizeof(caStemptime) - 1, "%s", utTimFormat("%Y%m", letime));    printf("caStemptime=======================%s\n", caStemptime);    snprintf(caUserorderTableName, sizeof(caUserorderTableName) - 1, "%s", getNewLogTable("userorderlog", caStemptime));    memset(sqlbuf, 0, sizeof(sqlbuf));    //获取日志表名    printf("caUserorderTableName=======================%s\n", caUserorderTableName);    //设置日志类型,这里设置为1,为订购    snprintf(userOrderLogType, sizeof(userOrderLogType) - 1, "1");    printf("sqlbuf=%s, iReturn=%d\n", sqlbuf, iReturn);    snprintf(sqlbuf, sizeof(sqlbuf), "insert into %s (username,mobno,mark,packageid,name,status,money,mtype,timeval,orderno,starttime,endtime)values('%s','%s','%s',%lu,'%s','%s',%lu,%d,%llu,'%s',%llu,%llu)", caUserorderTableName, caUsername, caMobno, caMark, u4PackageId, caPackageName, userOrderLogType, u4PackageMoney, iPaymentType, u8Dtime, caOrderno, u8StartTime, u8EndTime);    //printf("%s\n", sqlbuf);    pasLogs(7077, 7077, "ict_complete_package_order_zf sqlbuf=%s, iReturn=%d\n", sqlbuf, iReturn);    iReturn = pasDbExecSql(sqlbuf, 0);    printf("sqlbuf=%s, iReturn=%d\n", sqlbuf, iReturn);    memset(caMsg, 0, sizeof(caMsg));    if(iReturn != 0)    {        psData->status = 10;        //添加用户订购套餐日志失败,sql语句执行不成功!        pasDbRollback(NULL);//错误回滚        return 1;    }    else    {        //添加用户订购套餐日志成功        //snprintf(caMsg, sizeof(caMsg) - 1, "订购套餐执行成功!");        //utPltPutVar(psDbHead, "mesg", convert("GBK", "UTF-8", caMsg));        //utPltPutVarF(psDbHead, "result", "%d", 0);        //余额付款返回更新后的余额,如果不是余额付款,也返回目前账户的余额，以套餐付款方式区分        //utPltPutVarF(psDbHead, "accountBalance", "%lu", u4NewAccountMoney);        //utPltOutToHtml(iFd, psMsgHead, psDbHead, "school/package/complete_package_order.htm");        //余额付款不再返回，前台需要修改        psData->status = 1;        //添加用户订购套餐日志成功        pasDbCommit(NULL);//事物提交        //根据用户名获取用户密码        memset(sqlbuf, 0, sizeof(sqlbuf));        snprintf(sqlbuf, sizeof(sqlbuf) - 1, "select password,groupid from ncsrvuser where username='%s' ", caUsername);        iReturn = pasDbOneRecord(sqlbuf, 0, UT_TYPE_STRING, 31, caPassword,                                 UT_TYPE_LONG, 4, &lGroupid);        pasLogs(1234, 1233, "get passwoed sql =%s\n", sqlbuf);        if((iReturn == 0) || (1405 == iReturn))        {            //获取用户密码成功            /*snprintf(caMsg, sizeof(caMsg) - 1, "用户输入的登录密码错误");            utPltPutVar(psDbHead, "mesg", convert("GBK", "UTF-8", caMsg));            utPltPutVarF(psDbHead, "result", "%d", 6);            utPltOutToHtml(iFd, psMsgHead, psDbHead, "school/package/create_order_no.htm");            return 1;*/            ncPortalOnline* psOnline = (ncPortalOnline *)ncSrvGetOnlineUserByTsid(psShmHead, atoll(caTsid));            //userip            iReturn = letUserLogin(psShmHead, iFd, psMsgHead, psOnline, lGroupid, caUsername, utComHostIp(ntohl(psOnline->lSip)), caPassword, caTsid);            pasLogs(1234, 1233, "iReturn =letUserLogin =%d\n", iReturn);            return 0;        }        else        {        }    }}//公共函数c文件char* getMobnoByUsername(utShmHead *psShmHead, utMsgHead *psMsgHead, int iFd, char* caUsername){    static char caMobno[24] = {0};//用户绑定的手机号    char caMsg[256] = {0};    int iReturn = 0;    char sqlbuf[1024] = "";    utPltDbHead *psDbHead = utPltInitDbHead();    //获取手机号    memset(sqlbuf, 0, sizeof(sqlbuf));    snprintf(sqlbuf, sizeof(sqlbuf) - 1, "select mobno from ncsrvuserex where username=%s", caUsername);    iReturn = pasDbOneRecord(sqlbuf, 0,                             UT_TYPE_STRING, sizeof(caMobno) - 1, caMobno                            );    printf("sqlbuf=%s, iReturn=%d\n", sqlbuf, iReturn);    //sql语句执行成功    if((iReturn == 0) || (1405 == iReturn))    {        //获取手机号成功    }    else    {        snprintf(caMsg, sizeof(caMsg) - 1, "获取手机号失败!,sql语句执行不成功!");        utPltPutVar(psDbHead, "mesg", convert("GBK", "UTF-8", caMsg));        utPltPutVarF(psDbHead, "result", "%d", 4);        utPltOutToHtml(iFd, psMsgHead, psDbHead, "school/package/add_interaction_info.htm");    }    return caMobno;}static unsigned char char_to_hex(unsigned char x){    return (unsigned char)(x > 9 ? x + 55 : x + 48);}static int is_alpha_number_char(unsigned char c){    if((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9'))        return 1;    return 0;}//url编码实现void urlencode(unsigned char * src, int  src_len, unsigned char * dest, int  dest_len){    unsigned char ch;    int  len = 0;    while(len < (dest_len - 4) && *src)    {        ch = (unsigned char) * src;        if(*src == ' ')        {            *dest++ = '+';        }        else if(is_alpha_number_char(ch) || strchr("-_.!~*'()", ch))        {            *dest++ = *src;        }        else        {            *dest++ = '%';            *dest++ = char_to_hex((unsigned char)(ch >> 4));            *dest++ = char_to_hex((unsigned char)(ch % 16));        }        ++src;        ++len;    }    *dest = 0;    return ;}/*** @param str 需要解码的url字符串* @param len 需要解码的url的长度* @return int 返回解码后的url长度*/int urldecode(char *str, int len){    char *dest = str;    char *data = str;    int value;    int c;    while(len--)    {        if(*data == '+')        {            *dest = ' ';        }        else if(*data == '%' && len >= 2 && isxdigit((int) * (data + 1))                && isxdigit((int) * (data + 2)))        {            c = ((unsigned char *)(data + 1))[0];            if(isupper(c))                c = tolower(c);            value = (c >= '0' && c <= '9' ? c - '0' : c - 'a' + 10) * 16;            c = ((unsigned char *)(data + 1))[1];            if(isupper(c))                c = tolower(c);            value += c >= '0' && c <= '9' ? c - '0' : c - 'a' + 10;            *dest = (char)value ;            data += 2;            len -= 2;        }        else        {            *dest = *data;        }        data++;        dest++;    }    *dest = '\0';    return dest - str;}